# 🏃 Maze-Runner
Maze Runner Game (Java) – A Java-based maze navigation game developed as part of the Software Engineering process. The game challenges players to navigate through dynamic mazes, collect keys to unlock doors, avoid obstacles, monsters and escape with a record of time consumed. It includes a life system, timer and boosters for enhanced gameplay.

This project highlights the **software development lifecycle (SDLC)** including requirements gathering, system design, coding, testing, and documentation.

---

## 🎮 Game Features

- **Maze Navigation** – Move the player using `W`, `A`, `S`, `D` keys  
- **Keys & Doors** – Collect keys to unlock specific doors  
- **Obstacles** – Avoid monsters and hazards placed in the maze  
- **Life Mode** – Limited lives per game session  
- **Boosters** – Temporary speed boosts to escape faster  
- **Timer** – Complete the maze with a record of completio time

---

## 🛠️ Tech Stack

| Layer        | Technology  |
|--------------|-------------|
| Language     | Java        |
| Paradigm     | OOP         |
| Development  | Software Engineering Process (SDLC) |

---

## 🚀 Getting Started

### 1. Clone the Repository
```bash
git clone https://github.com/Shirleyngshuetling/Maze-Runner.git
cd Maze-Runner
````
### 2. Mark res as resource root
⚠️ Make sure `res/` is marked as Resources Root in your IDE (in IntelliJ, right-click `res` → Mark Directory as → Resources Root).

### 3. Compile the Project

```bash
javac Main.java
```

### 4. Run the Game

```bash
java Main
```

---

## 📂 Project Structure

* `Main.java` – Entry point of the game
* `Game.java` – Core game loop and logic
* `Player.java` – Player movement and state
* `Maze.java` – Maze generation and handling
* `Key.java`, `Door.java`, `Booster.java` – Game entities
* `utils/` – Helper classes

---

## ✅ Software Engineering Process

This project was built following the **Software Engineering Process**:

1. **Requirements Analysis** – Defined functional & non-functional requirements
2. **System Design** – Created UML diagrams and architecture design
3. **Implementation** – Developed in Java using OOP principles
4. **Testing** – Unit tests and playtesting for functionality & bugs
5. **Documentation** – Project report, UML diagrams, and README

---

## 🤝 Contributing

Contributions are welcome! You can help by:

* Enhancing the game with new levels or mechanics
* Improving UI/UX (menus, graphics)
* Refactoring code for efficiency
* Adding automated tests

---

## 📜 License

This project is currently **unlicensed**. Please contact the author for usage rights.

---

## 📧 Contact

For questions, suggestions, or contributions:

* Open an **issue** in this repository
* Or reach out directly via GitHub
